Это задание будет способствовать дальнейшему продвижению нас к интерпретатору Forth. Некоторые вещи об этом могут показаться принудительными, как макро дизайн, но это даст хорошую основу для переводчика, который мы собираемся сделать позже.

Наша задача-реализовать словарь. Это подразумевает соответствие между ключами и значениями.
Каждая запись содержит адрес следующей записи, ключ и значение. Ключи и значения в нашем случае являются нулевыми строками.
Записи словаря, образующие структуру данных, называются linked list. Пустой список представлен
null указатель, равным нулю. Непустой список является указателем на его первый элемент. Каждый элемент имеет какое-то значение и указатель на следующий элемент (или ноль, если это последний элемент).
В листинге 5-34 показан примерный связанный список, содержащий элементы 100, 200 и 300. На него можно ссылаться указатель на свой первый элемент, то есть x1.

...

Linked List часто полезен в ситуациях с многочисленными вставками и удалениями в середине
списка. Однако доступ к элементам по индексу затруднен, так как не сводится к простому указателю. Взаимные позиции связанных элементов списка в плоской памяти обычно не предсказуемы.
Учитывая это, словарь будет построен статически, как список, и каждый вновь определенный элемент
будет добавлен к нему. Необходимо использовать макросы с локальными метками и переопределение символов для автоматизации создания linked list. Мы явно поручаем вам сделать macro colon с двумя аргументами, где первый будет содержать строку-ключ словаря, а вторая будет содержать имя внутреннего представления элемента. Это разделение необходимо, так как ключевые строки иногда могут содержать символы, которые не являются валидными частями имени метки (пробел, знаки препинания, арифметические знаки и т. д.). Пример такого словаря приведен в листинге 5-35.

...

Назначение будет содержать следующие файлы:
 1.
main.asm
 2.
lib.asm
 3.
dict.asm
 4.
colon.inc

Выполните следующие действия, чтобы завершить задание:
1. Создайте отдельный файл сборки, содержащий уже написанные функции, которые вы уже написали
в первом задании. Мы будем называть его lib.o.
Не забудьте отметить все необходимые метки глобальными, иначе они не будут видны
вне этого файла объекта!
 
2. Создайте файл с colon.inc и определить макрос для создания словарных слов.
Этот макрос будет принимать два аргумента:
• Ключ (внутри кавычек).
* Имя метки сборки. Ключи могут содержать пробелы и другие символы, которые не
разрешены в именах меток.

Каждая запись должна начинаться с указателя на следующую запись, а затем содержать ключ, как null-
терминированную строку. Содержимое затем непосредственно описывается программистом,
например, с помощью директив db, как в примере, показанном в листинге 5-35.
 
3. Создайте функцию find_word внутри нового файла dict.аsm. Принимает два аргумента:
(а) указатель на null-терминированную строку.
(b) указатель на последнее слово в словаре. Имея указатель на последнее слово, мы можем следовать последовательно ссылкам для перечисления всех слов в словаре.

find_word будет охватывать весь словарь, сравнивая данный ключ с каждым ключом в словаре. Если запись не найдена, возвращается ноль; в противном случае возвращает адрес записи.
 
4. Отдельный файл содержит words.inc для определения словаря с помощью colon macro. Включите его в main.asm.

5. Простая функция _start. Она должен выполнять следующие действия:
* Считывать строку в буфер длиной не более 255 символов.
* Попробовать найти этот ключ в словаре. Если найдено, выведите соответствующее значение. Если нет,
выведите сообщение об ошибке.

Не забывайте: все сообщения об ошибках должны быть написаны в stderr, а не stdout!
Мы поставляем набор файлов заглушки (см. раздел 2.1 “Настройка окружающей среды”), вы можете использовать их.
Дополнительный файл Makefile описывает процесс построения; введите make в задания, чтобы построить
исполняемый файл main. Краткое руководство к системе GNU доступно в Приложении Б.
Как и в первом назначении, есть test.py файл для выполнения автоматизированных тестов.
