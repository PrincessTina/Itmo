В этом задании мы собираемся реализовать несколько функций более высокого порядка 
в связанных списках, которые должны 
быть знакомы тем, кто привык к функциональной
парадигме программирования.

Эти функции известны под названиями foreach, map, map_mut, и foldl.


• foreach принимает указатель на начало списка и функцию (которая возвращает void 
и 
принимает int). Он запускает функцию для каждого элемента списка.


• map принимает функцию f и список. Возвращает новый список, содержащий 
результаты
 f примененимой ко всем элементам исходного списка. На исходный список 
это не влияет. 
Например, f (x) = x + 1 отобразит список (1, 2, 3) в (2, 3, 4).


• map_mut делает то же самое, но изменяет список источников.


• foldl немного сложнее. Он принимает:

- Начальное значение аккумулятора.

- Функцию f (x, a).

– Список элементов.

Возвращает значение того же типа, что и аккумулятор, вычисляемое следующим образом:

1. Запускаем f на аккумуляторе и первом элементе списка. Результат - новое 
значение
аккумулятора a'.

2. Запускаем f на а' и втором элементе списка. Результат опять новый
 аккумулятор 
со значением а".

3. Повторяем процесс до тех пор, пока список не закончится (consumed). 
В конце концов, окончательное значение аккумулятора - 
конечный результат.

Например, давайте возьмем Ф (Х, А) = Х * А. Запустив foldl с значение сумматора 1 и
с этой функцией 
мы получим произведение всех элементов списка.


• iterate принимает начальное значение s, длину списка n и функцию f. 
Затем создается список 
длины n следующим образом:
 s, f(s), f(f(s)), f(f(f(s))), ...

Описанные выше функции называются функциями более высокого порядка, поскольку они 
принимают другие
 функции как аргументы. Другим примером такой функции является 
функция сортировки массива qsort.

void qsort( void *base,
	    size_t nmemb,
	    size_t size,
            int (*compar)(const void *, const void*));
Он принимает начальную адресную базу массива, количество элементов nmemb, размер 
размера отдельных элементов, 
функцию сравнения compar. Эта функция является
решающей и говорит, какой из данных
 элементов будет ближе к началу массива.


Входной файл содержит произвольное количество целых чисел.

1. Сохраните эти целые числа в связанном списке.

2. Перенесите все функции, записанные в предыдущем назначении, в отдельные 
.h и .c-файлы. 
Не забудьте их заинклюдить!

3. Используя foreach, выведите исходный список дважды: первый раз, 
отделив 
элементы пробелами, второй раз - каждый элемент на новой строке.

4. Используя map, вывести квадраты и кубы чисел списка.

5. Используя foldl, выведите сумму, минимальный и максимальный элемент
 списка.

6. Используя map_mut, выведите модули входных чисел.

7. Используя iterate, вывести создать и вывести список степеней двойки (первые 10 
значений: 1, 2, 4, 8, ...).


8. Реализовать функцию bool save(struct list* lst, const char* filename);, 

которая запишет все элементы списка в текстовый файл. Он должен вернуть true 
в случае успеха, false в противном случае.

9. Реализовать функцию  bool load(struct list** lst, const char* filename);, 

которая считает целые числа из текстового файла и запишет их в
 *lst. Он должен 
возвращать true в случае успеха записи, false в противном случае.

10. Сохраните список в текстовый файл и загрузите его обратно, используя две 
вышеперечисленные функции. Проверить, 
что сохранение и загрузка правильны.

11. Реализовать функции bool serialize(struct list* lst, const char*
filename);, которая запишет все элементы списка в двоичное имя файла. Она 
должна
возвращать true в случае, если запись прошла успешно, false в противном случае.

12. Реализовать функцию  bool deserialize(struct list** lst, const char*
filename);, которая будет считывать все целые числа из двоичного файла и записывать
в *lst. Он должен возвращать true в случае успешной записи, false 
иначе.

13. Сериализовать список в двоичный файл и загрузить его обратно, используя две 
вышеперечисленные функции. Проверить
, что сериализация и десериализация верны.


14. Освободите всю выделенную память.


Вам придется научиться пользоваться

• Указателями на функции.

• limits.h и константами из него. Например, для того, чтобы найти минимальный 
элемент массива, вы должны использовать foldl с максимальным возможным целым
значением в аккумуляторе, и функцией, возвращающей минимум из двух элементов.

• Ключевым словом static для функций, которые вы хотите использовать в одном 
модуле. 

Вам гарантировано, что

* Входной поток содержит только целочисленные числа, разделенные пробелами.

* Все числа из входных данных могут содержаться в виде int.

Возможно, целесообразно написать отдельную функцию для чтения списка из файла.

Решение занимает около 150 строк кода, не считая функций, определенных в 
предыдущем
 назначении.