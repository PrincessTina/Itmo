В этом задании мы создадим программу для выполнения фильтра сепии на изображении. Фильтр сепия превращает
изображение с яркими цветами в старую, выдержанную фотографию. Большинство графических редакторов включает сепию.
Сам фильтр кодировать не сложно. Он пересчитывает красную, зеленую и синюю компоненты каждого пикселя
на основе старых значений красного, зеленого и синего. Математически, если подумать о пикселе как о трех-
размерном векторе, преобразование-это не что иное, как умножение вектора на матрицу.
Пусть новое значение пикселя (B G R)^T (где Т верхний индекс означает транспонирование). B, G, и R остаются за синий, зеленый и красный уровни. В векторной форме преобразование можно описать следующим образом:
(B)    (b)    (c11  c12  c13)
(G)  = (g)  x (c21  c22  c23)
(R)    (r)    (c31  c32  c33)

В скалярной форме, мы можем переписать это как
B = bc11 + gc12 + rc13
G = bc21 + gc22 + rc23
R = bc31 + gc32 + rc33

В задании, приведенном в разделе 13.10, мы закодировали программу вращения изображения. Если вы продумали его архитектуру хорошо, будет легко повторно использовать большую часть из того кода.
Придется использовать насыщенную арифметику. Это означает, что все операции, такие как сложение и
умножение, ограничены фиксированным диапазоном между минимальным и максимальным значениями. Наша типичная арифметическая машина - модульная: если результат больше максимального значения, то мы придем в другую сторону диапазона. Например, для unsigned char: 200 + 100 = 300 mod 256 = 44. Арифметика насыщения подразумевает, что для того же диапазона от 0 до 255 включается 200 + 100 = 255, так как это максимальное значение диапазона.

В C не выполнить такие вычисления, так что нам придется проверять на переполнение вручную. SSE содержит
инструкции, которые преобразуют значения с плавающей точкой в однобайтовые целые числа с насыщением.
Проведение преобразований в языке C очень просто. Это требует прямого кодирования матрицы в векторное
произведение и учета насыщенности. В листинге 16-32 показан код.

Listing 16-32.  image_sepia_c_example.c

#include <inttypes.h>
struct pixel { uint8_t b, g, r; };

struct image {
    uint32_t width, height;
    struct pixel* array;
};

static unsigned char sat( uint64_t x) {
    if (x < 256) return x; return 255;
}

static void sepia_one( struct pixel* const pixel ) {
    static const float c[3][3] =  {
    { .393f, .769f, .189f },
    { .349f, .686f, .168f },
    { .272f, .543f, .131f } };
struct pixel const old = *pixel;

pixel->r = sat(
        old.r * c[0][0] + old.g * c[0][1] + old.b * c[0][2]
        );
pixel->g = sat(
        old.r * c[1][0] + old.g * c[1][1] + old.b  * c[1][2]
        );
pixel->b = sat(
        old.r * c[2][0] + old.g * c[2][1] + old.b * c[2][2]
        );
}

void sepia_c_inplace( struct image* img ) {
    uint32_t x,y;
    for( y = 0; y < img->height; y++ )
        for( x = 0; x < img->width; x++ )
            sepia_one( pixel_of( *img, x, y ) );
}

Обратите внимание, что использование uint8_t или unsigned char очень важно.
В этом задании вы должны
* Реализовать в отдельном файле процедуры применения фильтра к большой части изображения (за исключением
последних пикселей, возможно). Он будет работать на кусках нескольких пикселей одновременно, используя SSE
инструкции.
Последние несколько пикселей, которые не заполняли последний блок, могут быть обработаны по одному с помощью C-кода в листинге 16-32.

* Убедитесь, что версии C и ассемблера дают одинаковые результаты.
• Составьте две программы: в первой должен быть использован наивный С подход и во второй
следует использовать инструкции SSE.
* Сравните время выполнения C и SSE, используя в качестве входных данных огромное изображение
(желательно сотни мегабайт).
* Повторите сравнение несколько раз и вычислить средние значения для SSE и С.

Чтобы добиться заметных изменений, мы должны проводить как можно больше операций параллельно. Каждый пиксель состоит из 3 байт; после преобразования его компонентов в дробные числа он займет 12 байт. Каждый регистр xmm является шириной в 16 байт. Если мы хотим быть эффективными, мы также будем использовать последние 4 байта. Для достижения этого мы используем рамку 48 байт, что соответствует трем регистрам XMM, 12-пиксельным компонентам и 4 пикселам.
Пусть подписка обозначает индекс пикселя. Затем изображение выглядит следующим образом:
b1g1r1b2g2r2b3g3r3b4g4r4 ...

Мы хотели бы вычислить первые четыре компонента. Три из них соответствуют первому пикселю, 
четвертый соответствует второму.
Для выполнения необходимых преобразований полезно сначала поместить в регистры следующие значения:

xmm0 = b1b1b1b2
xmm1 = g1g1g1g2
xmm2 = r1r1r1r2

Мы будем хранить коэффициенты матрицы в регистрах XMM или памяти, но важно хранить
столбцы, а не строки.
Для демонстрации алгоритма мы будем использовать следующие начальные значения:

xmm3 = c11|c21|c31|c11
xmm4 = c12|c22|c32|c12
xmm5 = c13|c23|c33|c13

Мы используем mulps для умножения этих упакованных значений на xmm0...xmm2.

xmm3 = b1c11|b1c21|b1c31|b2c11
xmm4 = g1c12|g1c22|g1c32|g2c12
xmm5 = r1c13|r1c23|r1c33|r2c13

Следующим шагом является добавление их с помощью addps инструкции.
Подобные действия должны выполняться с двумя другими двумя 16-байтовыми частями кадра, содержащими
g2r2b3g3 и r3b4g4r4
Этот метод с использованием транспонированной матрицы коэффициентов позволяет справиться без горизонтального сложения инструкций, таких как haddps. Подробно описано в [19].
Для измерения времени, использовать вызов getrusage(RUSAGE_SELF, &р) (читать Man-страницы вызова getrusage сперва). Он заполняет структуру r типа struct rusage, чье поле r.ru_utime содержит поле типа struct timeval. Он содержит, в свою очередь, пару значений для потраченных секунд и потраченных millise conds. Сравнивая эти значения перед преобразованием и после этого можно вывести время, затраченное на трансформацию.

Listing 16-33 shows an example of single time measurement.

Listing 16-33.  execution_time.c

#include <sys/time.h>
#include <sys/resource.h>
#include <stdio.h>
#include <unistd.h>
#include <stdint.h>

int main(void) {
    struct rusage r;
    struct timeval start;
    struct timeval end;

    getrusage(RUSAGE_SELF, &r );
    start = r.ru_utime;

    for( uint64_t i = 0; i < 100000000; i++ );
    getrusage(RUSAGE_SELF, &r );

    end = r.ru_utime;

    long res = ((end.tv_sec - start.tv_sec) * 1000000L) +
        end.tv_usec - start.tv_usec;

    printf( "Time elapsed in microseconds: %ld\n", res );
    return 0;
}

Use a table to perform a fast conversion from unsigned char into float.
float const byte_to_float[] = {
    0.0f, 1.0f, 2.0f, ..., 255.0f };
