#ifndef DYNAMIC_ARRAY_AND_LINKED_LIST_LIST_H
#define DYNAMIC_ARRAY_AND_LINKED_LIST_LIST_H

/**
 * Двусвязный список на чанках
 * @tparam T - тип элементов списка
 */
template<typename T>
class List final {
    /**
     * Структура Chunk
     * Содержит ссылку на массив элементов чанка, количество элементов в массиве и ссылки на следующий / предыдущий чанки
     * Занимает 32 байта
     */
    struct Chunk {
        T *nodes; // массив элементов
        int length; // количество элементов в чанке
        Chunk *prev; // указатель на следующий чанк
        Chunk *next; // укзатель на предыдущий чанк
    };

    class Iterator {
        const List *readableList = nullptr; // указатель на список только для чтения
        List *list = nullptr; // указатель на список для чтения и записи
        Chunk *chunkPointer; // указатель на текущий чанк
        int nodeIndex = 0; // индекс текущего элемента в текущем чанке

    public:
        /**
         * Конструктор, инициализирует итератор
         * @param list - список, связанный с итератором (чтение и запись)
         * @param currentNodePointer - указатель на текущий элемент списка
         * @param chunkSize - размер чанка списка
         */
        Iterator(List *list, Chunk *chunkPointer);

        /**
         * Конструктор, инициализирует итератор
         * @param list список, связанный с итератором (чтение)
         * @param currentNodePointer - указатель на текущий элемент списка
         * @param chunkSize - размер чанка списка
         */
        Iterator(const List *readableList, Chunk *chunkPointer);

        /**
         * Возвращает элемент на текущей позиции итератора, если это возможно. Иначе выбрасывает ошибку
         * @return элемент на текущей позиции итератора
         */
        const T &get() const;

        /**
         * Перезаписывает элемент в текущей позиции итератора, если это возможно. Иначе выбрасывает ошибку
         * @param value - новый элемент
         */
        void set(const T &value);

        /**
         * Вставляет элемент в текущую позицию итератора, если это возможно. Иначе выбрасывает ошибку
         * @param value - элемент, который необходимо вставить
         */
        void insert(const T &value);

        /**
         * Удаляет элемент на текущей позиции итератора, если это возможно. Иначе выбрасывает ошибку
         */
        void remove();

        /**
         * Инкрементирует chunkPointer, если это возможно. Иначе выбрасывает ошибку
         */
        void next();

        /**
         * Декрементирует chunkPointer, если это возможно. Иначе выбрасывает ошибку
         */
        void prev();

        /**
         * Проверяет, есть ли следующий элемент в списке
         * @return true, если есть, иначе false
         */
        bool hasNext() const;

        /**
         * Проверяет, есть ли предыдущий элемент в списке
         * @return true, если есть, иначе false
         */
        bool hasPrev() const;
    };

    Chunk *headChunk = nullptr; // указатель на первый чанк списка
    Chunk *tailChunk = nullptr; // указатель на последний чанк списка
    int chunkSize = (64 - sizeof(Chunk)) / sizeof(T); // вместимость чанка, для int равен 8
    int nodesCount = 0; // количество элементов списка

private:
    /**
     * Выделяет память, необходимую для хранения нового чанка (chunkSize количество узлов)
     * @return указатель на выделенный участок памяти
     */
    Chunk *allocateChunk();

    /**
     * Освобождает память, оставшуюся после пустого чанка
     * @param chunk - указатель на начало чанка
     */
    void freeChunk(Chunk *chunk);

    /**
     * Выбрасывает ошибку выхода за пределы списка
     */
    static void throwException();

    void insertInChunk(Chunk *chunk, int index, const T &value);

    void removeFromChunk(Chunk *chunk, int index);

public:
    /**
     * Конструктор
     * Выделяет память, необходимую для первого чанка
     */
    List();

    //List(const List&) = delete; // запрет копирования

    /**
     * Запрет оператора присваивания
     * @return
     */
    List& operator=(const List&) = delete;

    /**
     * Деструктор
     * Освобождает память
     */
    ~List();

    /**
     * Вставляет элемент со значением value в начало списка
     * Если элемент должен выйти за границы отеденного ему чанка, выделяет новый чанк и помещает элемент туда
     * (а именно в последнюю позицию)
     * @param value - значение элемента
     */
    void insertHead(const T &value);

    /**
     * Вставляет элемент со значением value в конец списка
     * Если элемент должен выйти за границы отеденного ему чанка, выделяет новый чанк и помещает элемент туда
     * (а именно в первую позицию)
     * @param value - значение элемента
     */
    void insertTail(const T &value);

    /**
     * Удаляет элемент из начала списка, если это возможно. Иначе выбрасывает ошибку
     */
    void removeHead();

    /**
     * Удаляет элемент из конца списка, если это возможно. Иначе выбрасывает ошибку
     */
    void removeTail();

    /**
     * Возвращает значение первого элемента списка
     * @return значение первого элемента списка
     */
    const T &head() const;

    /**
     * Возвращает значение последнего элемента списка
     * @return значение последнего элемента списка
     */
    const T &tail() const;

    /**
     * Возвращает количество элементов списка
     * @return количество элементов списка
     */
    int size() const;

    /**
     * Возвращает итератор (по умолчанию указывающий на первый элемент списка)
     * Если первый элемент не определен, итератор так же будет не определен
     * @return итератор (чтение и запись)
     */
    Iterator iterator();

    /**
     * Возвращает итератор (по умолчанию указывающий на первый элемент списка)
     * Если первый элемент не определен, итератор так же будет не определен
     * @return итератор (чтение)
     */
    Iterator iterator() const;
};

#include "list_impl.h"

#endif //DYNAMIC_ARRAY_AND_LINKED_LIST_LIST_H
