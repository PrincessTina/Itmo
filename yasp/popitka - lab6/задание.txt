В этом задании, мы собираемся реализовать нашу собственную версию malloc и free на основе системы распределения памяти, вызывая mmap и связанный список блоков произвольных размеров. Его можно рассматривать как упрощенную версию диспетчера памяти, типичного для стандартной библиотеки С и разделяющего большинство его слабостей. 
Для выполнения данного задания, использование malloc/calloc, free и realloc запрещено.

Как известно, эти функции используются для управления кучей. Куча состоит из анонимных страниц
и, на самом деле, является связанным списком блоков. Каждый блок состоит из заголовка и данных. Заголовок описывается структурой, показанной в листинге 13-19.

struct mem  {
    struct mem* next;
    size_t capacity;
    bool is_free;
};

Заголовок сразу же следует за используемой областью.
Нам нужно сохранить и размер, и ссылку на следующий блок, потому что в нашем случае куча может иметь пробелы по двум причинам:
• Начало "кучи" может быть размещено между двумя уже зарезервированными регионами.
* Куча может вырасти до произвольного размера.

Выделение в куче разделяет первый доступный кусок на два (учитывать его размер достаточно). Он помечает первую часть как несвободную и возвращает ее адрес. Если нет свободных кусков достаточно больших для требуемого размера, то аллокатор пытается получить больше памяти от операционной системы путем вызова mmap.
Нет смысла выделять блоки на 1 или 3 байта; они слишком малы. Обычно это просто трата времени, так как размер заголовка в любом случае имеет больший размер. Таким образом, мы собираемся ввести постоянную BLOCK_MIN_SIZE для минимального разрешенного размера блока (не включая заголовок).
Учитывая запрос на запрашиваемое число байт, мы сначала изменим его на BLOCK_MIN_SIZE, если оно слишком мало. Затем мы пройдем по цепочке блоков и применим следующую логику к каждому блоку:
• query <= capacity-sizeof(struct mem) - MINIMAL_BLOCK_SIZE

В этом случае мы можем разделить блок на два и использовать первую часть как выделенный блок памяти, оставив второй свободным.
* В противном случае блок недостаточно велик для хранения требуемого количества байтов.

– Если блок не последний, то перейдем к следующему блоку.
- В противном случае нам нужно сопоставить больше страниц (достаточно найти ту, чтобы можно было выделить запрашиваемые байты).

Сначала попробуем сделать это сразу после окончания блока (флаг MAP_FIXED для mmap), и, если получится, то
увеличим текущий блок для включения новых страниц. В конце мы разделим его на два и используем первую часть.
Если мы не можем сопоставить больше страниц сразу в конце кучи, мы пытаемся сопоставить их в любом другом месте (достаточном, чтобы выделить запрашиваемые). Затем разделим его на два и используем первую пару.
Если все сопоставления не удаются, мы возвращаем NULL, так же, как и malloc.
free легче реализовать. Учитывая начало блока, мы должны вычислить соответствующее начало заголовка,
который поменяет свой статус с “выделенный” на “свободный.” Если сразу после него последует свободный блок, то они сольются. Но не в том случае, когда блок является последним в своей области памяти и следующий располагается после одиночного пробела. Вы можете использовать файл-заголовок, показанного в листинге 13-20.

#ifndef _MEM_H_
#define _MEM_H_

#define _USE_MISC

#include <stddef.h>
#include  <stdint.h>
#include <stdio.h>

#include <sys/mman.h>

#define  HEAP_START  ((void*)0x04040000)

struct mem;

#pragma pack(push, 1)
struct mem  {
    struct mem* next;
    size_t capacity;
    bool is_free;
};
#pragma pack(pop)

void* _malloc(size_t query);
void  _free(void* mem);
void* init(size_t initial_size);
#define DEBUG_FIRST_BYTES 4

void memalloc_debug_struct_info(FILE* f, struct mem const* const address);
void memalloc_debug_heap(FILE* f, struct mem const* ptr);
#endif

Помните, что сложная логика побуждает к продуманному разложению на меньшие функции.
Код, показанный в листинге 13-21, можно использовать для отладки состояния кучи. Не забывайте, что вы можете также ждать ввода пользователя и проверять файл /proc/PID/maps, чтобы увидеть фактические сопоставления процесса с идентификатором PID.

#include "mem.h"

void memalloc_debug_struct_info(FILE* f, struct mem const* const address) {
    size_t i;

    fprintf(f, "start: %p\nsize: %lu\nis_free: %d\n", (void*)address, address-> capacity,
            address-> is_free);
    
    for (i = 0; i <  DEBUG_FIRST_BYTES  &&  i < address-> capacity; ++i)
        fprintf(f, "%hhX", ((char*)address)[ sizeof( struct mem_t ) + i ]);

    putc('\n', f);
}

void memalloc_debug_heap(FILE* f, struct mem const* ptr) {
    for( ; ptr; ptr = ptr->next)
        memalloc_debug_struct_info(f, ptr);
}

Предполагаемое количество строк кода от 150 до 200. Не забудьте написать make-файл.
