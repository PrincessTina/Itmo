Программа принимает произвольное число целых чисел через stdin. 
Что вам нужно сделать, это:

1. Сохранить их в связанном списке в обратном порядке.

2. Написать функцию для вычисления суммы элементов связанного списка.

3. Использовать эту функцию для вычисления суммы элементов списка.

4. Напишите функцию для вывода n-го элемента списка. Если список слишком 

короткий, просигнализируйте об этом.

5. Освободите память, выделенную для связанного списка.
 
Вы должны научиться использовать

* Структурные типы для кодирования самого связанного списка.

* Константу EOF. Прочитайте раздел “Возвращаемое значение” scanf.

Вы можете быть уверены, что

* Входные данные не содержат ничего, кроме целых чисел, разделенных пробелами.

* Все входные числа могут содержаться в int переменных.


Ниже приведен рекомендуемый список функций для реализации:

* list_create - принимает число, возвращает указатель на новый узел связанного 
списка (to the new linked list node).

* list_add_front - принимает число и указатель на указатель на связанный список.

Добавляет новый узел с номером в списке.
 Например: список (1,2,3), число 5, 
и новый список (5,1,2,3).

* list_add_back - добавляет элемент в конец списка. Сигнатура такая же, 
как
 list_add_front.

* list_get получает элемент по индексу или возвращает 0, если индекс находится за 
пределами списка.

* list_free освобождает память, выделенную всем элементам списка.

* list_length принимает список и вычисляет его длину.

• list_node_at принимает список и индекс, возвращает указатель на структуру,

соответствующую узлу по этому индексу. Если индекс слишком велик, возвращает 
значение NULL.

* list_sum принимает список, возвращает сумму элементов.


Это некоторые дополнительные требования:

* Все части логики, которые используются не один раз (или те, которые могут быть 
концептуально 
изолированы) должны быть абстрагированы в функции и повторно 
использованы.

* Исключением из предыдущего требования является снижение производительности

критически, потому что повторное использование кода изменяет алгоритм радикально 
неэффективным способом. 
Например, вы можете использовать list_at функцию, 
чтобы получить N-й элемент списка в 
цикле для вычисления суммы всех элементов. 
Тем не менее, первый должен пройти через 
весь список, чтобы добраться до элемента. 
По мере увеличения n, вы будете проходить те же элементы
 снова и снова.


Фактически, для списка длины N можно считать в те разы, когда к элементам
обращались, чтобы 
вычислить сумму.


Начнем с суммы, равной 0. Затем добавим первый элемент, для этого нужно обратиться
к нему одному. 
Затем добавляем второй элемент, обращаясь к первому и второму. 
В конце концов, что 
мы получаем что-то вроде O(N2
) для тех, кто знаком с 
O-нотацией. По сути это означает, что при увеличении 
размера списка на 1, 
время, чтобы суммировать такой список, будет иметь N добавлений к нему.

В таком случае, действительно, разумнее просто пройти через список, добавив в него
текущий элемент к аккумулятору.

* Написание небольших функций очень хорошо в большую часть времени.

* Рассмотрим возможность написания отдельных функций, чтобы: добавить элемент на 
фронт, добавить на заднюю часть, 
создать новый узел связанного списка.

• Не забудьте широко использовать const, специально в функциях принимая указатели 
как 
аргументы!
