#ifndef DYNAMIC_ARRAY_AND_LINKED_LIST_LIST_H
#define DYNAMIC_ARRAY_AND_LINKED_LIST_LIST_H



/**
 * Двусвязный список на чанках
 * @tparam T - тип элементов списка
 */
template<typename T>
class List final {
    static const int chunkSize = (sizeof(T) < 40) ? (64 - 24) / sizeof(T) : 1; // вместимость чанка, для int равен 10

    /**
     * Структура Chunk
     * Содержит ссылку на массив элементов чанка, количество элементов в массиве и ссылки на следующий / предыдущий чанки
     * Занимает 24 байта
     */
    struct Chunk {
        T nodes[chunkSize]; // массив элементов
        int length; // количество элементов в чанке
        Chunk *prev; // указатель на следующий чанк
        Chunk *next; // укзатель на предыдущий чанк
    };

    class Iterator {
        const List *readableList = nullptr; // указатель на список только для чтения
        List *list = nullptr; // указатель на список для чтения и записи
        Chunk *chunkPointer; // указатель на текущий чанк
        int nodeIndex = 0; // индекс текущего элемента в текущем чанке

    public:
        /**
         * Конструктор, инициализирует итератор
         * @param list - список, связанный с итератором (чтение и запись)
         * @param chunkPointer - указатель на первый чанк списка
         */
        Iterator(List *list, Chunk *chunkPointer);

        /**
         * Конструктор, инициализирует итератор
         * @param readableList - список, связанный с итератором (чтение)
         * @param chunkPointer - указатель на первый чанк списка
         */
        Iterator(const List *readableList, Chunk *chunkPointer);

        /**
         * Возвращает значение элемента на текущей позиции итератора, если это возможно. Иначе выбрасывает ошибку
         * @return значение элемента на текущей позиции итератора
         */
        const T &get() const;

        /**
         * Перезаписывает значение элемента в текущей позиции итератора, если это возможно. Иначе выбрасывает ошибку
         * @param value - новое значение элемента
         */
        void set(const T &value);

        /**
         * Вставляет элемент в текущую позицию итератора, если это возможно. Иначе выбрасывает ошибку
         * @param value - значение элемента, который необходимо вставить
         */
        void insert(const T &value);

        /**
         * Удаляет элемент на текущей позиции итератора, если это возможно. Иначе выбрасывает ошибку
         */
        void remove();

        /**
         * Инкрементирует nodeIndex, если это возможно. Иначе выбрасывает ошибку
         */
        void next();

        /**
         * Декрементирует nodeIndex, если это возможно. Иначе выбрасывает ошибку
         */
        void prev();

        /**
         * Проверяет, есть ли следующий элемент в списке
         * @return true, если есть, иначе false
         */
        bool hasNext() const;

        /**
         * Проверяет, есть ли предыдущий элемент в списке
         * @return true, если есть, иначе false
         */
        bool hasPrev() const;
    };

    Chunk *headChunk = nullptr; // указатель на первый чанк списка
    Chunk *tailChunk = nullptr; // указатель на последний чанк списка
    int nodesCount = 0; // количество элементов списка

private:
    /**
     * Выбрасывает ошибку выхода за пределы списка
     */
    static void throwException();

    /**
     * Выделяет память, необходимую для хранения нового чанка (chunkSize количество узлов)
     * @return указатель на выделенный участок памяти
     */
    Chunk *allocateChunk();

    /**
     * Освобождает память, оставшуюся после пустого чанка
     * @param chunk - указатель на начало чанка
     */
    void freeChunk(Chunk *chunk);

    /**
     * Осуществляет вставку элемента в чанк по индексу, сдвигая элементы при необходимости
     * @param chunk - чанк, в который необходимо вставить элемент
     * @param index - индекс элемента в чанке, куда необходимо вставить новый элемент
     * @param value - значение нового элемента
     */
    void insertInChunk(Chunk *chunk, int index, const T &value);

    /**
     * Осуществляет удаление элемента из чанка по индексу, сдвигая элементы при необходимости
     * @param chunk - чанк, из которого необходимо удалить элемент
     * @param index - индекс элемента в чанке, который необходимо удалить
     */
    void removeFromChunk(Chunk *chunk, int index);

    /**
     * Перемещает часть чанка, расположенную левее, в часть чанка, расположенную правее
     * @param chunkFrom - чанк, часть которого перемещается
     * @param chunkTo - чанк, в который будет записана новая часть
     * @return количество элементов, которое было перемещено
     */
    int relocateChunkPartToRight(Chunk *chunkFrom, Chunk *chunkTo);

    /**
     * Перемещает часть чанка, расположенную правее, в часть чанка, расположенную левее
     * @param chunkFrom - чанк, часть которого перемещается
     * @param chunkTo - чанк, в который будет записана новая часть
     */
    void relocateChunkPartToLeft(Chunk *chunkFrom, Chunk *chunkTo);

    /**
     * Осуществляет вставку элемента в список
     * @param chunkPointer - чанк, в который необходимо вставить элемент
     * @param index - индекс элемента в чанке, куда необходимо вставить новый элемент
     * @param value - значение нового элемента
     * @return индекс элемента в чанке, куда был вставлен элемент
     */
    int insert(Chunk *chunkPointer, int index, const T &value);

    /**
     * Осуществляет удаление элемента из списка
     * Выбрасывает ошибку выхода за границы списка, если изначальное количество узлов равно 0
     * @param chunkPointer - чанк, из которого необходимо удалить элемент
     * @param index - индекс элемента в чанке, который необходимо удалить
     * @return индекс элемента в чанке, куда был вставлен элемент
     */
    int remove(Chunk *chunkPointer, int index);

public:
    /**
     * Конструктор
     * Выделяет память, необходимую для первого чанка
     */
    List();

    //List(const List&) = delete; // запрет копирования

    /**
     * Запрет оператора присваивания
     * @return
     */
    List& operator=(const List&) = delete;

    /**
     * Деструктор
     * Освобождает память
     */
    ~List();

    /**
     * Вставляет элемент со значением value в начало списка
     * @param value - значение элемента
     */
    void insertHead(const T &value);

    /**
     * Вставляет элемент со значением value в конец списка
     * @param value - значение элемента
     */
    void insertTail(const T &value);

    /**
     * Удаляет элемент из начала списка, если это возможно. Иначе выбрасывает ошибку
     */
    void removeHead();

    /**
     * Удаляет элемент из конца списка, если это возможно. Иначе выбрасывает ошибку
     */
    void removeTail();

    /**
     * Возвращает значение первого элемента списка, если это возможно. Иначе выбрасывает ошибку
     * @return значение первого элемента списка
     */
    const T &head() const;

    /**
     * Возвращает значение последнего элемента списка, если это возможно. Иначе выбрасывает ошибку
     * @return значение последнего элемента списка
     */
    const T &tail() const;

    /**
     * Возвращает количество элементов списка
     * @return количество элементов списка
     */
    int size() const;

    /**
     * Возвращает итератор (по умолчанию указывающий на первый элемент списка)
     * @return итератор (чтение и запись)
     */
    Iterator iterator();

    /**
     * Возвращает итератор (по умолчанию указывающий на первый элемент списка)
     * @return итератор (чтение)
     */
    Iterator iterator() const;
};

#include "list_impl.h"

#endif //DYNAMIC_ARRAY_AND_LINKED_LIST_LIST_H
