#ifndef DYNAMIC_ARRAY_AND_LINKED_LIST_LIST_H
#define DYNAMIC_ARRAY_AND_LINKED_LIST_LIST_H

/**
 * Двусвязный список на чанках
 * @tparam T - тип элементов списка
 */
template<typename T>
class List final {
    struct Node {
        T value; // значение элемента
        int index; // индекс элемента в текущем чанке
        Node *nextChunk = nullptr; // указатель на элемент следующего (слева или справа) чанка
    };

    class Iterator {
        const List *readableList = nullptr; // указатель на список только для чтения
        List *list = nullptr; // указатель на список для чтения и записи
        Node *currentNodePointer; // указатель на текущий элемент списка
        int chunkSize; // размер чанка списка

    public:
        /**
         * Конструктор, инициализирует итератор
         * @param list - список, связанный с итератором (чтение и запись)
         * @param currentNodePointer - указатель на текущий элемент списка
         * @param chunkSize - размер чанка списка
         */
        Iterator(List *list, Node *currentNodePointer, int chunkSize);

        /**
         * Конструктор, инициализирует итератор
         * @param list список, связанный с итератором (чтение)
         * @param currentNodePointer - указатель на текущий элемент списка
         * @param chunkSize - размер чанка списка
         */
        Iterator(const List *list, Node *currentNodePointer, int chunkSize);

        /**
         * Возвращает элемент на текущей позиции итератора, если это возможно. Иначе выбрасывает ошибку
         * @return элемент на текущей позиции итератора
         */
        const T &get() const;

        /**
         * Перезаписывает элемент в текущей позиции итератора, если это возможно. Иначе выбрасывает ошибку
         * @param value - новый элемент
         */
        void set(const T &value);

        /**
         * Вставляет элемент в текущую позицию итератора, если это возможно. Иначе выбрасывает ошибку
         * @param value - элемент, который необходимо вставить
         */
        void insert(const T &value);

        /**
         * Удаляет элемент на текущей позиции итератора, если это возможно. Иначе выбрасывает ошибку
         */
        void remove();

        /**
         * Инкрементирует currentNodePointer, если это возможно. Иначе выбрасывает ошибку
         */
        void next();

        /**
         * Декрементирует currentNodePointer, если это возможно. Иначе выбрасывает ошибку
         */
        void prev();

        /**
         * Проверяет, есть ли следующий элемент в списке
         * @return true, если есть, иначе false
         */
        bool hasNext() const;

        /**
         * Проверяет, есть ли предыдущий элемент в списке
         * @return true, если есть, иначе false
         */
        bool hasPrev() const;
    };

    Node *headNode = nullptr; // указатель на начало списка
    Node *tailNode = nullptr; // указатель на конец списка
    int chunkSize = 64 / sizeof(Node); // размер чанка
    int nodesCount = 0; // количество элементов списка

private:
    /**
     * Выделяет память, необходимую для нового чанка (chunkSize количество узлов)
     * @return указатель на выделенный участок памяти
     */
    Node *allocateChunk();

    /**
     * Освобождает память, оставшуюся после пустого чанка
     * @param chunk - указатель на начало чанка
     */
    void freeChunk(Node *chunk);

    /**
     * Выбрасывает ошибку выхода за пределы списка
     */
    static void throwException();

public:
    /**
     * Конструктор
     * Выделяет память, необходимую для первого чанка
     */
    List();

    //List(const List&) = delete; // запрет копирования

    /**
     * Запрет оператора присваивания
     * @return
     */
    List& operator=(const List&) = delete;

    /**
     * Деструктор
     * Освобождает память
     */
    ~List();

    /**
     * Вставляет элемент со значением value в начало списка
     * Если элемент должен выйти за границы отеденного ему чанка, выделяет новый чанк и помещает элемент туда
     * (а именно в последнюю позицию)
     * @param value - значение элемента
     */
    void insertHead(const T &value);

    /**
     * Вставляет элемент со значением value в конец списка
     * Если элемент должен выйти за границы отеденного ему чанка, выделяет новый чанк и помещает элемент туда
     * (а именно в первую позицию)
     * @param value - значение элемента
     */
    void insertTail(const T &value);

    /**
     * Удаляет элемент из начала списка, если это возможно. Иначе выбрасывает ошибку
     */
    void removeHead();

    /**
     * Удаляет элемент из конца списка, если это возможно. Иначе выбрасывает ошибку
     */
    void removeTail();

    /**
     * Возвращает значение первого элемента списка
     * @return значение первого элемента списка
     */
    const T &head() const;

    /**
     * Возвращает значение последнего элемента списка
     * @return значение последнего элемента списка
     */
    const T &tail() const;

    /**
     * Возвращает количество элементов списка
     * @return количество элементов списка
     */
    int size() const;

    /**
     * Возвращает итератор (по умолчанию указывающий на первый элемент списка)
     * Если первый элемент не определен, итератор так же будет не определен
     * @return итератор (чтение и запись)
     */
    Iterator iterator();

    /**
     * Возвращает итератор (по умолчанию указывающий на первый элемент списка)
     * Если первый элемент не определен, итератор так же будет не определен
     * @return итератор (чтение)
     */
    Iterator iterator() const;
};


#include "list_impl.h"

#endif //DYNAMIC_ARRAY_AND_LINKED_LIST_LIST_H
